"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var libxml = require("../index");
if (!global.gc) {
    throw new Error("must run with --expose_gc for ref integrity tests");
}
module.exports.gc = function (assert) {
    var _a, _b, _c, _d, _e, _f;
    var doc = libxml.Document();
    (_d = (_c = (_b = (_a = doc.node("root")) === null || _a === void 0 ? void 0 : _a.node("child")) === null || _b === void 0 ? void 0 : _b.node("grandchild")) === null || _c === void 0 ? void 0 : _c.parent()) === null || _d === void 0 ? void 0 : _d.node("child2");
    global.gc();
    assert.ok(doc, "doc");
    global.gc();
    assert.ok(doc.root(), "root");
    global.gc();
    assert.equal("child", (_f = (_e = doc.root()) === null || _e === void 0 ? void 0 : _e.childNodes()[0]) === null || _f === void 0 ? void 0 : _f.name(), "child name");
    assert.done();
};
module.exports.references = function (assert) {
    var _a, _b;
    var nodes = libxml.parseXml("<root> <child> <grandchildren/> </child> <child2/> </root>").childNodes();
    global.gc();
    assert.ok((_a = nodes[0]) === null || _a === void 0 ? void 0 : _a.doc());
    assert.equal("child", (_b = nodes[1]) === null || _b === void 0 ? void 0 : _b.name());
    assert.done();
};
module.exports.double_free = function (assert) {
    var children = null;
    (function () {
        var html = "<html><body><div><span></span></div></body></html>";
        var doc = libxml.parseHtml(html);
        doc.find("//div").forEach(function (tag) {
            children = tag.childNodes();
            tag.remove();
        });
    })();
    global.gc();
    assert.ok(children[0].attrs());
    assert.done();
};
module.exports.freed_namespace_unwrappable = function (assert) {
    var doc = libxml.parseXml("<?xml version='1.0' encoding='UTF-8'?><root></root>");
    var el = libxml.Element(doc, "foo");
    var ns = el.namespace("bar", null);
    el = null;
    global.gc();
    ns = null;
    global.gc();
    assert.done();
};
module.exports.unlinked_tree_persistence_parent_proxied_first = function (assert) {
    var doc = makeDocument();
    var parent_node = doc.get("//middle");
    var child_node = doc.get("//inner");
    parent_node.remove();
    parent_node = null;
    collectGarbage();
    assert.equal("inner", child_node.name());
    assert.done();
};
module.exports.unlinked_tree_proxied_leaf_persistent_ancestor_first = function (assert) {
    var doc = makeDocument();
    var ancestor = doc.get("//middle");
    var leaf = doc.get("//center");
    ancestor.remove();
    ancestor = null;
    collectGarbage();
    assert.equal("center", leaf.name());
    assert.done();
};
module.exports.unlinked_tree_proxied_leaf_persistent_descendant_first = function (assert) {
    var doc = makeDocument();
    var leaf = doc.get("//center");
    var ancestor = doc.get("//middle");
    ancestor.remove();
    ancestor = null;
    collectGarbage();
    assert.equal("center", leaf.name());
    assert.done();
};
module.exports.unlinked_tree_persistence_child_proxied_first = function (assert) {
    var doc = makeDocument();
    var child_node = doc.get("//inner");
    var parent_node = doc.get("//middle");
    parent_node.remove();
    parent_node = null;
    collectGarbage();
    assert.equal("inner", child_node.name());
    assert.done();
};
module.exports.unlinked_tree_leaf_persistence_with_proxied_ancestor = function (assert) {
    var doc = makeDocument();
    var proxied_ancestor = doc.get("//inner");
    var leaf = doc.get("//center");
    doc.get("//middle").remove();
    leaf = null;
    collectGarbage();
    leaf = proxied_ancestor.get(".//center");
    assert.equal("center", leaf.name());
    assert.done();
};
module.exports.unlinked_tree_leaf_persistence_with_peer_proxy = function (assert) {
    var _a;
    var doc = makeDocument();
    var leaf = doc.get("//left");
    var peer = doc.get("//right");
    doc.get("//middle").remove();
    leaf = null;
    collectGarbage();
    leaf = (_a = peer.parent()) === null || _a === void 0 ? void 0 : _a.get("./left");
    assert.equal("left", leaf.name());
    assert.done();
};
module.exports.set_text_clobbering_children = function (assert) {
    var doc = libxml.parseHtml("<root><child><inner>old</inner></child></root>");
    var child = doc.get("//child");
    var inner = doc.get("//inner");
    child.text("new");
    assert.equal(doc, inner.parent());
    assert.equal("old", inner.text());
    assert.done();
};
function makeDocument() {
    var body = "<?xml version='1.0' encoding='UTF-8'?>\n" +
        "<root><outer><middle><inner><left/><center/><right/></inner></middle></outer></root>";
    return libxml.parseXml(body);
}
function collectGarbage(minCycles, maxCycles) {
    minCycles = minCycles || 3;
    maxCycles = maxCycles || 10;
    var cycles = 0;
    var freedRss = 0;
    var usage = process.memoryUsage();
    do {
        global.gc();
        var usageAfterGc = process.memoryUsage();
        freedRss = usage.rss - usageAfterGc.rss;
        usage = usageAfterGc;
        cycles++;
    } while (cycles < minCycles || (freedRss !== 0 && cycles < maxCycles));
    return usage;
}
//# sourceMappingURL=ref_integrity.js.map