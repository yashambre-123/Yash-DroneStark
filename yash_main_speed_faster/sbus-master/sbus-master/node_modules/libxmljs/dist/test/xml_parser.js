"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var libxml = require("../index");
var index_1 = require("../index");
module.exports.parse = function (assert) {
    var _a, _b;
    var filename = __dirname + "/../../test/fixtures/parser.xml";
    var str = fs.readFileSync(filename, "utf8").replace(/[\r]+/g, '');
    var doc = libxml.parseXml(str);
    assert.equal("1.0", doc.version());
    assert.equal("UTF-8", doc.encoding());
    assert.equal("root", (_a = doc.root()) === null || _a === void 0 ? void 0 : _a.name());
    assert.equal("child", doc.get("child").name());
    assert.equal("grandchild", doc.get("child").get("grandchild").name());
    assert.equal("with love", doc.get("child/grandchild").text());
    assert.equal("sibling", doc.get("sibling").name());
    assert.equal(6, doc.get("sibling").line());
    assert.equal(3, (_b = doc.get("child").getAttribute("to")) === null || _b === void 0 ? void 0 : _b.line());
    assert.equal("with content!", doc.get("sibling").text());
    assert.equal(str, doc.toString());
    assert.done();
};
module.exports.parse_with_flags = function (assert) {
    var filename = __dirname + "/../../test/fixtures/parser.xml";
    var str = fs.readFileSync(filename, "utf8").replace(/[\r]+/g, '');
    var doc = libxml.parseXml(str, { replaceEntities: true, validateEntities: true });
    assert.equal(18, doc.getParseFlags());
    assert.done();
};
module.exports.parseAsync = function (assert) {
    var filename = __dirname + "/../../test/fixtures/parser.xml";
    var str = fs.readFileSync(filename, "utf8").replace(/[\r]+/g, '');
    var x = 0;
    libxml.parseXmlAsync(str).then(function (doc) {
        var _a, _b;
        assert.equal(++x, 2);
        assert.equal("1.0", doc.version());
        assert.equal("UTF-8", doc.encoding());
        assert.equal("root", (_a = doc.root()) === null || _a === void 0 ? void 0 : _a.name());
        assert.equal("child", doc.get("child").name());
        assert.equal("grandchild", doc.get("child").get("grandchild").name());
        assert.equal("with love", doc.get("child/grandchild").text());
        assert.equal("sibling", doc.get("sibling").name());
        assert.equal(6, doc.get("sibling").line());
        assert.equal(3, (_b = doc.get("child").getAttribute("to")) === null || _b === void 0 ? void 0 : _b.line());
        assert.equal("with content!", doc.get("sibling").text());
        assert.equal(str, doc.toString());
        assert.done();
    });
    assert.equal(++x, 1);
};
module.exports.parse_async_with_replace = function (assert) {
    var filename = __dirname + "/../../test/fixtures/parser.xml";
    var str = fs.readFileSync(filename, "utf8").replace(/[\r]+/g, '');
    var x = 0;
    libxml.parseXmlAsync(str, { replaceEntities: true, validateEntities: true }).then(function (doc) {
        assert.equal(18, doc.getParseFlags());
        assert.done();
    });
    assert.equal(++x, 1);
};
module.exports.parse_buffer = function (assert) {
    var _a;
    var filename = __dirname + "/../../test/fixtures/parser-utf16.xml";
    var buf = fs.readFileSync(filename);
    var doc = libxml.parseXml(buf);
    assert.equal("1.0", doc.version());
    assert.equal("UTF-16", doc.encoding());
    assert.equal("root", (_a = doc.root()) === null || _a === void 0 ? void 0 : _a.name());
    assert.done();
};
module.exports.recoverable_parse = function (assert) {
    var filename = __dirname + "/../../test/fixtures/warnings/ent9.xml";
    var str = fs.readFileSync(filename, "utf8");
    var doc = libxml.parseXml(str);
    assert.equal(1, doc.errors.length);
    var err = doc.errors.shift();
    assert.ok(err instanceof Error);
    assert.equal(err.domain, 3);
    assert.equal(err.column, 13);
    assert.equal(err.line, 1);
    assert.equal(err.code, 201);
    assert.equal(err.str1, "prefix");
    assert.done();
};
module.exports.baseurl_xml = function (assert) {
    if (/^win/.test(process.platform)) {
        assert.done();
        return;
    }
    var str = '<!DOCTYPE example SYSTEM "baseurl.dtd">\n' + '<example msg="&happy;"/>\n';
    var doc = libxml.Document.fromXml(str, {
        validateEntities: true,
        replaceEntities: true,
    });
    assert.ok(doc.errors.length > 0);
    var doc = libxml.Document.fromXml(str, {
        validateEntities: true,
        replaceEntities: true,
        baseUrl: __dirname + "/../../test/fixtures/example.xml",
    });
    assert.equal(doc.errors.length, 0);
    assert.done();
};
module.exports.fatal_error = function (assert) {
    var filename = __dirname + "/../../test/fixtures/errors/comment.xml";
    var str = fs.readFileSync(filename, "utf8");
    var err = null;
    try {
        libxml.parseXml(str);
    }
    catch (e) {
        if (e instanceof index_1.XMLStructuredError) {
            err = e;
        }
    }
    var errorControl = {
        domain: 1,
        code: 4,
        message: "Start tag expected, '<' not found\n",
        level: 3,
        file: null,
        line: 5,
        str1: null,
        str2: null,
        str3: null,
        int1: null,
        column: 10,
    };
    assert.ok(err instanceof Error);
    assert.equal(errorControl.code, err === null || err === void 0 ? void 0 : err.code);
    assert.done();
};
module.exports.parse_options = function (assert) {
    function test_parser_option(input, options, expected, saveOptions) {
        var output = libxml.parseXml(input, options).toString(saveOptions);
        output = output.replace(/^<\?xml version="1.0" encoding="UTF-8"\?>\n/, "");
        output = output.replace(/\n$/, "");
        assert.equal(output, expected);
    }
    test_parser_option("<x>&</x>", { recover: true }, "<x/>");
    test_parser_option("<!DOCTYPE x [ <!ENTITY foo 'bar'> ]> <x>&foo;</x>", { replaceEntities: true }, '<!DOCTYPE x [\n<!ENTITY foo "bar">\n]>\n<x>bar</x>');
    test_parser_option("<x> <a>123</a> </x>", {}, "<x> <a>123</a> </x>");
    test_parser_option("<x> <a>123</a> </x>", { preserveWhitespace: false }, "<x>\n  <a>123</a>\n</x>");
    test_parser_option("<x><![CDATA[hi]]></x>", {}, "<x><![CDATA[hi]]></x>");
    test_parser_option("<x><![CDATA[hi]]></x>", { preserveCDATA: false }, "<x>hi</x>");
    var TAB = "    ";
    var TEXT_CONTENT = "\n".concat(TAB).concat(TAB, "test test\n").concat(TAB);
    var ORIGINAL = "<x attr=\"test\">\n\n".concat(TAB, "<a>123</a>\n\n").concat(TAB, "<b>").concat(TEXT_CONTENT, "</b>\n\n</x>"), XML_FORMATTED = "<x attr=\"test\">\n  <a>123</a>\n  <b>".concat(TEXT_CONTENT, "</b>\n</x>"), NO_WHITESPACE = "<x attr=\"test\"><a>123</a><b>".concat(TEXT_CONTENT, "</b></x>");
    test_parser_option(ORIGINAL, { preserveWhitespace: true }, ORIGINAL);
    test_parser_option(ORIGINAL, { preserveWhitespace: true }, ORIGINAL, { format: true, type: "html" });
    test_parser_option(ORIGINAL, { preserveWhitespace: true }, ORIGINAL, { format: false });
    test_parser_option(NO_WHITESPACE, { preserveWhitespace: true }, NO_WHITESPACE, { format: false });
    test_parser_option(NO_WHITESPACE, { preserveWhitespace: true }, XML_FORMATTED, { format: true });
    test_parser_option(ORIGINAL, { preserveWhitespace: false }, XML_FORMATTED);
    test_parser_option(ORIGINAL, { preserveWhitespace: false }, XML_FORMATTED, { format: true });
    test_parser_option(ORIGINAL, { preserveWhitespace: false }, NO_WHITESPACE, { format: false });
    assert.done();
};
//# sourceMappingURL=xml_parser.js.map