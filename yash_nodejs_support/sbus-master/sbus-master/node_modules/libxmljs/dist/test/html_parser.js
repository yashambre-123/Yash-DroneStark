"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var index_1 = require("../index");
var index_2 = require("../index");
var TEST_DIR = __dirname + "/../../test";
function make_error(object) {
    var err = new Error(object.message);
    err.domain = object.domain;
    err.code = object.code;
    err.level = object.level;
    err.line = object.line;
    err.column = object.column;
    return err;
}
module.exports.parse = function (assert) {
    var filename = TEST_DIR + "/fixtures/parser.html";
    function attempt_parse(encoding) {
        var _a;
        var str = fs.readFileSync(filename, encoding);
        var doc = (0, index_2.parseHtml)(str);
        assert.equal("html", (_a = doc.root()) === null || _a === void 0 ? void 0 : _a.name());
        assert.equal("Test HTML document", doc.get("head/title").text());
        assert.equal("HTML content!", doc.get("body/span").text());
    }
    attempt_parse("utf-8");
    attempt_parse(null);
    assert.done();
};
module.exports.parseAsync = function (assert) {
    var filename = TEST_DIR + "/fixtures/parser.html";
    function attempt_parse(encoding) {
        var str = fs.readFileSync(filename, encoding);
        var x = 0;
        index_1.default.parseHtmlAsync(str).then(function (doc) {
            var _a;
            assert.equal(++x, 2);
            assert.equal("html", (_a = doc.root()) === null || _a === void 0 ? void 0 : _a.name());
            assert.equal("Test HTML document", doc.get("head/title").text());
            assert.equal("HTML content!", doc.get("body/span").text());
        });
        assert.equal(++x, 1);
    }
    attempt_parse("utf-8");
    attempt_parse(null);
    assert.done();
};
module.exports.parse_force_encoding = function (assert) {
    var filename = TEST_DIR + "/fixtures/parser.euc_jp.html";
    function attempt_parse(encoding, opts) {
        var _a, _b;
        var str = fs.readFileSync(filename, encoding);
        var doc = index_1.default.parseHtml(str, opts);
        assert.equal(doc.errors, 0);
        assert.equal("html", (_a = doc.root()) === null || _a === void 0 ? void 0 : _a.name());
        (_b = doc.root()) === null || _b === void 0 ? void 0 : _b.toString();
        var result = doc.find("/html/head/meta/@content")[0];
        var fixedCharset = result.value();
        assert.ok(fixedCharset.indexOf(opts.encoding.toUpperCase()) !== -1);
        assert.equal("テスト", doc.get("head/title").text());
        assert.equal("テスト", doc.get("body/div").text());
    }
    attempt_parse("utf-8", { encoding: "utf-8" });
    attempt_parse(null, { encoding: "utf-8" });
    assert.done();
};
module.exports.recoverable_parse = function (assert) {
    var _a, _b, _c, _d, _e;
    var recoverableFile = TEST_DIR + "/fixtures/warnings/amp.html";
    var str = fs.readFileSync(recoverableFile, "utf8");
    var recoverableErrors = [
        make_error({
            domain: 5,
            code: 23,
            message: "htmlParseEntityRef: expecting ';'\n",
            level: 2,
            line: 12,
            column: 27,
        }),
        make_error({ domain: 5, code: 68, message: "htmlParseEntityRef: no name\n", level: 2, line: 12, column: 38 }),
        make_error({
            domain: 5,
            code: 23,
            message: "htmlParseEntityRef: expecting ';'\n",
            level: 2,
            line: 14,
            column: 4,
        }),
        make_error({ domain: 5, code: 68, message: "htmlParseEntityRef: no name\n", level: 2, line: 15, column: 4 }),
    ];
    var doc = index_1.default.parseHtml(str);
    assert.equal(4, doc.errors.length);
    for (var i = 0; i < recoverableErrors.length; i++) {
        assert.equal(recoverableErrors[i].domain, (_a = doc.errors[i]) === null || _a === void 0 ? void 0 : _a.domain);
        assert.equal(recoverableErrors[i].code, (_b = doc.errors[i]) === null || _b === void 0 ? void 0 : _b.code);
        assert.equal(recoverableErrors[i].message, (_c = doc.errors[i]) === null || _c === void 0 ? void 0 : _c.message);
        assert.equal(recoverableErrors[i].level, (_d = doc.errors[i]) === null || _d === void 0 ? void 0 : _d.level);
        assert.equal(recoverableErrors[i].line, (_e = doc.errors[i]) === null || _e === void 0 ? void 0 : _e.line);
    }
    assert.done();
};
module.exports.parseOptions = function (assert) {
    var doc = index_1.default.parseHtml("<a/>", { doctype: false, implied: false }).toString();
    assert.ok(doc.indexOf("DOCTYPE") === -1);
    assert.ok(doc.indexOf("body") === -1);
    assert.ok(doc.indexOf("<html>") === -1);
    doc = index_1.default.parseHtml("<a/>", { doctype: false, implied: true }).toString();
    assert.ok(doc.indexOf("DOCTYPE") === -1);
    assert.ok(doc.indexOf("body") > -1);
    assert.ok(doc.indexOf("<html>") > -1);
    doc = index_1.default.parseHtml("<a/>", { implied: false }).toString();
    assert.ok(doc.indexOf("DOCTYPE") > -1);
    assert.ok(doc.indexOf("body") === -1);
    assert.ok(doc.indexOf("<html>") === -1);
    assert.done();
};
module.exports.toString = function (assert) {
    var doc = index_1.default.Document();
    assert.ok(doc.toString({ declaration: false }) === "");
    assert.equal(doc.toString({ declaration: false, type: "html" }), "\n");
    doc = index_1.default.parseHtml("<a></a>");
    assert.ok(doc.toString().indexOf("<?xml") === -1);
    assert.ok(doc.toString({ type: "xml" }).indexOf("<?xml") > -1);
    assert.ok(doc.toString({ type: "xhtml" }).indexOf("<?xml") > -1);
    assert.ok(doc.toString({ type: "xml", selfCloseEmpty: true }).indexOf("<a/>") > -1);
    assert.done();
};
//# sourceMappingURL=html_parser.js.map